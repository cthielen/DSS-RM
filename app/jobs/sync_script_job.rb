require 'sync'

# Runs a single sync script for a single user/role job.
# These jobs are generated by the sync subsystem found in lib/sync.rb.
# Do not create these jobs outside lib/sync.rb.
SyncScriptJob = Struct.new(:job_uuid, :sync_script, :sync_json) do
  # def enqueue(job)
  # end

  def perform
    # Call the script, piping the JSON
    ret = IO.popen(sync_script, 'r+', :err => [:child, :out]) do |pipe|
      pipe.puts sync_json
      pipe.close_write
      pipe.gets(nil)
    end

    if $?.exitstatus != 0
      Sync.logger.error "#{job_uuid}: #{sync_script}: ERROR"
      Sync.logger.error "#{job_uuid}: #{sync_script}: \t" + ret.gsub("\n", "\n#{job_uuid}: #{sync_script}: \t") if ret and ret.length > 0
      raise 'Sync script returned an error.'
    else
      Sync.logger.debug "#{job_uuid}: #{sync_script}: SUCCESS"
      Sync.logger.info "#{job_uuid}: #{sync_script}: \t" + ret.gsub("\n", "\n#{job_uuid}: #{sync_script}: \t") if ret and ret.length > 0
    end
  end

  # def before(job)
  # end

  # def after(job)
  # end

  # def success(job)
  # end

  # We don't need to care about error because we throw the error ourselves
  # in 'perform' if the external script fails.
  # def error(job, exception)
  # end

  def failure(job)
    # TODO: Make the failure e-mail delivery address configurable
    WheneverMailer.sync_script_failed("dssit-devs@ucdavis.edu", job).deliver!
  end

  def reschedule_at(current_time, attempts)
    current_time + 30.seconds + (120.seconds * attempts)
  end

  def max_attempts
    10
  end

  def max_run_time
    28800 # 8 hours (in seconds)
  end
end
